const fs = require('fs');
const app = require('../app.js');
const Models = require('../Models/index.js');
const { MAILTYPES, sendEmailRequest } = require('../Emails/enzoMails.js');
const db = require('../Models/database.js');
const helpers = require('../Helpers/helpers.js');
const { makeEmailValues } = require('../Utilities/utilities.js');
const SETTINGS = require('../settings.json') ;
const { START_PRECHECK_INVITE, QRCODE_PRECHECK_COMPLETED } = SETTINGS.EMAIL_TEMPLATE_FILE;

var intervalCheckID = null; //this is to store the intervalID generated by the emailResend process in order to trigger the getEmailError function 

const renderAndSendEmail = async (type, values, mailTracking = null) => {
    console.log('renderAndSendEmail start ...', type);
    console.log('renderAndSendEmail start ...', mailTracking);
    let template = type === MAILTYPES.START ? START_PRECHECK_INVITE : QRCODE_PRECHECK_COMPLETED; //get the template file name TODO: move this filename in the settings
    try {
        let mailTrackingObj = mailTracking || new Models.EmailTracking({ 
            reservationID: values.reservationId, 
            hotelID: values.hotelId, 
            emailType: type 
        });
        ++mailTrackingObj.attempts;
        return app.render(template, values, async (err, content) => {
            let manager;
            try {
                let attach = type === MAILTYPES.QR ? values.base64qrCode : fs.readFileSync('./Views/base64image.txt') ;
                manager = new db.HotelPmsDB();
                if (err) throw err ;
                if (values.email && values.email.toLowerCase().includes('adrien@enzosystems.com')) {
                    await sendEmailRequest(type, content, values.email, mailTrackingObj.messageID, attach);
                }
                if (mailTracking) await manager.updateEmailTrackingInfo(mailTrackingObj) ;
                else await manager.addEmailTrackingInfo(mailTrackingObj);
            } catch (e) {
                mailTrackingObj.sentDate = null ;
                if (!manager) manager = new db.HotelPmsDB(); //if the error come while no db manager, we get a new one. 
                if (mailTracking) await manager.updateEmailTrackingInfo(mailTrackingObj) ;
                else await manager.addEmailTrackingInfo(mailTrackingObj);
                console.log('renderAndSendEmail error ...', type);
                //as an error was throw, we start the checks by setting the intervalCheckID variable
                if (!intervalCheckID) return startCheckMailErrors() ;
                throw e ; //TODO : Test => not sure we need to re-throw the error as it's handled and the response headers should be already sent 
            }
        });
    } catch (e) {
        console.log(e);
        throw e;
    }
}

const getEmailErrors = async () => {
    console.log('check email error table for emails to resend...')
    try{
        let manager = new db.HotelPmsDB();
        let results = await manager.getEmailError();  
        if (!results.length) return stopCheckMailErrors();
        results.map(async (item) => {
            let emailSentObject = new Models.EmailTracking({ 
                reservationID: item.reservation,
                hotelID: item.hotel, 
                emailType: item.email_type, 
                sentDate: item.email_sent_date,
                sendingDate: item.email_sending_date, 
                messageID: item.message_id,
                attempts: item.attempts 
            }); 
            let result = await helpers.getReservations(emailSentObject.hotelID, emailSentObject.reservationID);
            let hotel = await manager.getHotelDetails(emailSentObject.hotelID);
            let values = await makeEmailValues(emailSentObject.emailType, result[emailSentObject.hotelID].reservations[0] , hotel);
            await renderAndSendEmail(emailSentObject.emailType, values, emailSentObject);          
        });
    } catch (e) {
        console.log(e);
        throw e;
    }
}

const startGetMailError = () => setInterval(getEmailErrors, SETTINGS.EMAIL_RETRY_DELAY_MINUTES * 60 * 1000);
    
const startCheckMailErrors = () => {
    try{
        intervalCheckID = startGetMailError() ;
        console.log('check email error  Interval ID ', intervalCheckID);
        return intervalCheckID;
    } catch (e) {
        console.log(e);
        throw e;
    }
}

const stopCheckMailErrors = () => {
    if (intervalCheckID) clearInterval(intervalCheckID);
    console.log('no error: clear email error Interval ID ', intervalCheckID);
    intervalCheckID = null;
}

module.exports = {
    renderAndSendEmail, 
    getEmailErrors,
    startCheckMailErrors,
    stopCheckMailErrors,
    intervalCheckID
}

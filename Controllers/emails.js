const app = require('../app.js');
const Models = require('../Models/index.js');
const { MAILTYPES, sendEmailRequest } = require('../Emails/enzoMails.js');
const db = require('../Models/database.js');
const helpers = require('../Helpers/helpers.js');
const { makeEmailValues } = require('../Utilities/utilities.js');
const SETTINGS = require('../settings.json') ;
const { START_PRECHECK_INVITE, QRCODE_PRECHECK_COMPLETED } = SETTINGS.EMAIL_TEMPLATE_FILE;

//store the intervalID generated by the emailResend process 
//triggered by the sendEmailRequest() function error catch block 
//if set, the lookup to resend emails is triggered at a specified interval 
//until there is no more email sending error 
var intervalCheckID = null; 

//Render and send the email from templates regarding the email type requested and using the values object to fill the placeholders
//in the email error context, a mailtracking object can be provided with the previous email values that weren't sent due to errors  
const renderAndSendEmail = async (type, values, mailTracking = null) => {
    //get the template file name 
    let template = type === MAILTYPES.START ? START_PRECHECK_INVITE : QRCODE_PRECHECK_COMPLETED; 
    try {
        //set the mailTracking object from the passed argument or create a new one for new email
        let mailTrackingObj = (mailTracking instanceof Models.EmailTracking ) ? mailTracking : new Models.EmailTracking({ 
            reservationID: values.reservationId, 
            hotelID: values.hotelId, 
            emailType: type
        });
        //add +1 to sending attempts
        ++mailTrackingObj.attempts;
        //call the express rendering engine for htm files define in app.js
        return app.render(template, values, async (err, content) => {
            let manager = new db.HotelPmsDB();
            let mailTrack = mailTrackingObj; 
            try {
                if (err) throw err ;
                //set the email attachment file for the image/qrCode from the base64 string or from the image file
                //TO DO: import the image from the hotel settings 
                let attach = type === MAILTYPES.QR ? values.base64qrCode : values.base64image ;
                if (values.email && values.email.toLowerCase().includes('adrien@enzosystems.com'))
                    await sendEmailRequest(type, content, values.email, mailTrackingObj.messageID, attach);
            } catch (e) {
                mailTrack.sentDate = null ;
                console.log('renderAndSendEmail error ...', e);
                //as an error was throw, we start the email errors checks by setting the intervalCheckID variable if it wasn't already
                if (!intervalCheckID) return startCheckMailErrors() ;
               // throw e ; //TODO : Test => not sure we need to re-throw the error as it's handled and the response headers should be already sent 
            } finally {
                //if no db manager anymore, we get a new one. 
                console.log('renderAndSendEmail finally ...update emailTrack', mailTrack);
                if (!manager) manager = new db.HotelPmsDB(); 
                if (mailTrack.attempts > 1) await manager.updateEmailTrackingInfo(mailTrack) ;
                else await manager.addEmailTrackingInfo(mailTrack);
            }
        });
    } catch (e) {
        console.log(e);
        throw e;
    }
}

//check email tracking table for error and emails to resend...
const getEmailErrors = async () => {
    console.log('check email error table for emails to resend...');
    try{
        let manager = new db.HotelPmsDB();
        //get the email errors from the email tracking table
        let results = await manager.getEmailError();  
        //if no result we can unset the intervalID and stop the lookup 
        if (!results.length) return stopCheckMailErrors();
        //otherwise for each email that wasn't sent
        results.forEach(async (item) => {
            try{
                //make an EmailTracking Object 
                let emailSentObject = new Models.EmailTracking({ 
                    reservationID: item.reservation,
                    hotelID: item.hotel, 
                    emailType: item.email_type, 
                    sentDate: item.sent_date,
                    sendingDate: item.sending_date, 
                    messageID: item.message_id,
                    attempts: item.attempts 
                }); 
                //get the reservation  
                let result = await helpers.getReservations(emailSentObject.hotelID, emailSentObject.reservationID);
                //get the hotel details  
                let hotel = await manager.getHotelDetails(emailSentObject.hotelID);
                //generate the email template values 
                let values = await makeEmailValues(emailSentObject.emailType, result[emailSentObject.hotelID].reservations[0], hotel);
                //render and send the email 
                await renderAndSendEmail(emailSentObject.emailType, values, emailSentObject);
            } catch (e) {
                throw e;
            } 
        });
    } catch (e) {
        console.log(e);
        throw e;
    }
}


//set the intervalCheckID variable, to start the email error lookup and resend process
const startCheckMailErrors = () => {
         if (!intervalCheckID) intervalCheckID = setInterval(getEmailErrors, SETTINGS.EMAIL_RETRY_DELAY_MINUTES * 60 * 1000);
        console.log('check email error  Interval ID ', intervalCheckID);
}

//unset the intervalCheckID to stop the the email error lookup and resend process
const stopCheckMailErrors = () => {
    if (intervalCheckID) clearInterval(intervalCheckID);
    console.log('no error: clear email error Interval ID ', intervalCheckID);
    intervalCheckID = null;
}

module.exports = {
    renderAndSendEmail, 
    getEmailErrors,
    startCheckMailErrors,
    stopCheckMailErrors,
    intervalCheckID
}
